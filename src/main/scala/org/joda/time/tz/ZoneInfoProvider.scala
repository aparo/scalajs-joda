/*
 *  Copyright 2001-2013 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.tz

import java.io.DataInputStream
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.io.InputStream
import java.lang.ref.SoftReference
import java.util.Collections
import java.util.Map
import java.util.Set
import java.util.TreeSet
import java.util.concurrent.ConcurrentHashMap
import org.joda.time.DateTimeZone

/**
 * ZoneInfoProvider loads compiled data files as generated by
 * {@link ZoneInfoCompiler}.
 * <p>
 * ZoneInfoProvider is thread-safe and publicly immutable.
 *
 * @author Brian S O'Neill
 * @since 1.0
 */
object ZoneInfoProvider {
  /**
   * Loads the zone info map.
   *
   * @param in  the input stream
   * @return the map
   */
  @throws(classOf[IOException])
  private def loadZoneInfoMap(in: InputStream): Map[String, AnyRef] = {
    val map: Map[String, AnyRef] = new ConcurrentHashMap[String, AnyRef]
    val din: DataInputStream = new DataInputStream(in)
    try {
      readZoneInfoMap(din, map)
    } finally {
      try {
        din.close
      }
      catch {
        case ex: IOException => {
        }
      }
    }
    map.put("UTC", new SoftReference[DateTimeZone](DateTimeZone.UTC))
    return map
  }

  /**
   * Reads the zone info map from file.
   *
   * @param din  the input stream
   * @param zimap  gets filled with string id to string id mappings
   */
  @throws(classOf[IOException])
  private def readZoneInfoMap(din: DataInputStream, zimap: Map[String, AnyRef]) {
    var size: Int = din.readUnsignedShort
    val pool: Array[String] = new Array[String](size)
    {
      var i: Int = 0
      while (i < size) {
        {
          pool(i) = din.readUTF.intern
        }
        ({
          i += 1; i - 1
        })
      }
    }
    size = din.readUnsignedShort
    {
      var i: Int = 0
      while (i < size) {
        {
          try {
            zimap.put(pool(din.readUnsignedShort), pool(din.readUnsignedShort))
          }
          catch {
            case ex: ArrayIndexOutOfBoundsException => {
              throw new IOException("Corrupt zone info map")
            }
          }
        }
        ({
          i += 1; i - 1
        })
      }
    }
  }
}

class ZoneInfoProvider extends Provider {
  /** The directory where the files are held. */
  private final val iFileDir: File = null
  /** The resource path. */
  private final val iResourcePath: String = null
  /** The class loader to use. */
  private final val iLoader: ClassLoader = null
  /** Maps ids to strings or SoftReferences to DateTimeZones. */
  private final val iZoneInfoMap: Map[String, AnyRef] = null
  /** Maps ids to strings or SoftReferences to DateTimeZones. */
  private final val iZoneInfoKeys: Set[String] = null

  /**
   * ZoneInfoProvider searches the given directory for compiled data files.
   *
   * @throws IOException if directory or map file cannot be read
   */
  @throws(classOf[IOException])
  def this(fileDir: File) {
    this()
    if (fileDir == null) {
      throw new IllegalArgumentException("No file directory provided")
    }
    if (!fileDir.exists) {
      throw new IOException("File directory doesn't exist: " + fileDir)
    }
    if (!fileDir.isDirectory) {
      throw new IOException("File doesn't refer to a directory: " + fileDir)
    }
    iFileDir = fileDir
    iResourcePath = null
    iLoader = null
    iZoneInfoMap = ZoneInfoProvider.loadZoneInfoMap(openResource("ZoneInfoMap"))
    iZoneInfoKeys = Collections.unmodifiableSortedSet(new TreeSet[String](iZoneInfoMap.keySet))
  }

  /**
   * ZoneInfoProvider searches the given ClassLoader resource path for
   * compiled data files. Resources are loaded from the ClassLoader that
   * loaded this class.
   *
   * @throws IOException if directory or map file cannot be read
   */
  @throws(classOf[IOException])
  def this(resourcePath: String) {
    this()
    `this`(resourcePath, null, false)
  }

  /**
   * ZoneInfoProvider searches the given ClassLoader resource path for
   * compiled data files.
   *
   * @param loader ClassLoader to load compiled data files from. If null,
   *               use system ClassLoader.
   * @throws IOException if directory or map file cannot be read
   */
  @throws(classOf[IOException])
  def this(resourcePath: String, loader: ClassLoader) {
    this()
    `this`(resourcePath, loader, true)
  }

  /**
   * @param favorSystemLoader when true, use the system class loader if
   *                          loader null. When false, use the current class loader if loader is null.
   */
  @throws(classOf[IOException])
  private def this(resourcePath: String, loader: ClassLoader, favorSystemLoader: Boolean) {
    this()
    if (resourcePath == null) {
      throw new IllegalArgumentException("No resource path provided")
    }
    if (!resourcePath.endsWith("/")) {
      resourcePath += '/'
    }
    iFileDir = null
    iResourcePath = resourcePath
    if (loader == null && !favorSystemLoader) {
      loader = getClass.getClassLoader
    }
    iLoader = loader
    iZoneInfoMap = ZoneInfoProvider.loadZoneInfoMap(openResource("ZoneInfoMap"))
    iZoneInfoKeys = Collections.unmodifiableSortedSet(new TreeSet[String](iZoneInfoMap.keySet))
  }

  /**
   * If an error is thrown while loading zone data, the exception is logged
   * to system error and null is returned for this and all future requests.
   *
   * @param id  the id to load
   * @return the loaded zone
   */
  def getZone(id: String): DateTimeZone = {
    if (id == null) {
      return null
    }
    val obj: AnyRef = iZoneInfoMap.get(id)
    if (obj == null) {
      return null
    }
    if (obj.isInstanceOf[SoftReference[_]]) {
      @SuppressWarnings(Array("unchecked")) val ref: SoftReference[DateTimeZone] = obj.asInstanceOf[SoftReference[DateTimeZone]]
      val tz: DateTimeZone = ref.get
      if (tz != null) {
        return tz
      }
      return loadZoneData(id)
    }
    else if (id == obj) {
      return loadZoneData(id)
    }
    return getZone(obj.asInstanceOf[String])
  }

  /**
   * Gets a list of all the available zone ids.
   *
   * @return the zone ids
   */
  def getAvailableIDs: Set[String] = {
    return iZoneInfoKeys
  }

  /**
   * Called if an exception is thrown from getZone while loading zone data.
   *
   * @param ex  the exception
   */
  protected def uncaughtException(ex: Exception) {
    ex.printStackTrace
  }

  /**
   * Opens a resource from file or classpath.
   *
   * @param name  the name to open
   * @return the input stream
   * @throws IOException if an error occurs
   */
  @SuppressWarnings(Array("resource"))
  @throws(classOf[IOException])
  private def openResource(name: String): InputStream = {
    var in: InputStream = null
    if (iFileDir != null) {
      in = new FileInputStream(new File(iFileDir, name))
    }
    else {
      val path: String = iResourcePath.concat(name)
      if (iLoader != null) {
        in = iLoader.getResourceAsStream(path)
      }
      else {
        in = ClassLoader.getSystemResourceAsStream(path)
      }
      if (in == null) {
        val buf: StringBuilder = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(if (iLoader != null) iLoader.toString else "system")
        throw new IOException(buf.toString)
      }
    }
    return in
  }

  /**
   * Loads the time zone data for one id.
   *
   * @param id  the id to load
   * @return the zone
   */
  private def loadZoneData(id: String): DateTimeZone = {
    var in: InputStream = null
    try {
      in = openResource(id)
      val tz: DateTimeZone = DateTimeZoneBuilder.readFrom(in, id)
      iZoneInfoMap.put(id, new SoftReference[DateTimeZone](tz))
      return tz
    }
    catch {
      case ex: IOException => {
        uncaughtException(ex)
        iZoneInfoMap.remove(id)
        return null
      }
    } finally {
      try {
        if (in != null) {
          in.close
        }
      }
      catch {
        case ex: IOException => {
        }
      }
    }
  }
}